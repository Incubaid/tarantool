-- Generated by lua-capnproto 0.1.3-1 on Sun Jul 23 08:59:09 2017
-- https://github.com/cloudflare/lua-capnproto.git


local ffi = require "ffi"
local capnp = require "capnp"
local bit = require "bit"

local ceil              = math.ceil
local write_struct_field= capnp.write_struct_field
local read_struct_field = capnp.read_struct_field
local read_text         = capnp.read_text
local write_text        = capnp.write_text
local get_enum_val      = capnp.get_enum_val
local get_enum_name     = capnp.get_enum_name
local get_data_off      = capnp.get_data_off
local write_listp_buf   = capnp.write_listp_buf
local write_structp_buf = capnp.write_structp_buf
local write_structp     = capnp.write_structp
local read_struct_buf   = capnp.read_struct_buf
local read_listp_struct = capnp.read_listp_struct
local read_list_data    = capnp.read_list_data
local write_list        = capnp.write_list
local write_list_data   = capnp.write_list_data
local ffi_new           = ffi.new
local ffi_string        = ffi.string
local ffi_cast          = ffi.cast
local ffi_copy          = ffi.copy
local ffi_fill          = ffi.fill
local ffi_typeof        = ffi.typeof
local band, bor, bxor = bit.band, bit.bor, bit.bxor

local pint8    = ffi_typeof("int8_t *")
local pint16   = ffi_typeof("int16_t *")
local pint32   = ffi_typeof("int32_t *")
local pint64   = ffi_typeof("int64_t *")
local puint8   = ffi_typeof("uint8_t *")
local puint16  = ffi_typeof("uint16_t *")
local puint32  = ffi_typeof("uint32_t *")
local puint64  = ffi_typeof("uint64_t *")
local pbool    = ffi_typeof("uint8_t *")
local pfloat32 = ffi_typeof("float *")
local pfloat64 = ffi_typeof("double *")


local ok, new_tab = pcall(require, "table.new")

if not ok then
    new_tab = function (narr, nrec) return {} end
end

local round8 = function(size)
    return ceil(size / 8) * 8
end

local str_buf
local default_segment_size = 4096

local function get_str_buf(size)
    if size > default_segment_size then
        return ffi_new("char[?]", size)
    end

    if not str_buf then
        str_buf = ffi_new("char[?]", default_segment_size)
    end
    return str_buf
end

-- Estimated from #nodes, not accurate
local _M = new_tab(0, 16)


_M.Issue = {
    id = "14990458584466796407",
    displayName = "Big.capnp:Issue",
    dataWordCount = 2,
    pointerCount = 9,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 16,

    fields = {
        { name = "title", default = "", ["type"] = "text" },
        { name = "repo", default = "", ["type"] = "text" },
        { name = "milestone", default = "", ["type"] = "text" },
        { name = "assignees", default = "opaque pointer", ["type"] = "list" },
        { name = "is_closed", default = 0, ["type"] = "bool" },
        { name = "comments", default = "opaque pointer", ["type"] = "list" },
        { name = "labels", default = "opaque pointer", ["type"] = "list" },
        { name = "content", default = "", ["type"] = "text" },
        { name = "organization", default = "", ["type"] = "text" },
        { name = "mod_time", default = 0, ["type"] = "uint32" },
        { name = "creation_time", default = 0, ["type"] = "uint32" },
        { name = "git_host_refs", default = "opaque pointer", ["type"] = "list" },
        { name = "state", default = "new", ["type"] = "enum" },
        { name = "priority", default = "minor", ["type"] = "enum" },
        { name = "type", default = "unknown", ["type"] = "enum" },
        { name = "in_github", default = 0, ["type"] = "bool" },
    },

    calc_size_struct = function(data)
        local size = 88
        local value
        -- text
        value = data["title"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["repo"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["milestone"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- list
        if data["assignees"] and type(data["assignees"]) == "table" then
            local num2 = #data["assignees"]
            for i2=1, num2 do
                size = size + 8
                 -- num * acutal size
                size = size + round8(#data["assignees"][i2] * 1 + 1)
            end
        end
        -- list
        if data["comments"] and type(data["comments"]) == "table" then
            size = size + 8
            local num2 = #data["comments"]
            for i2=1, num2 do
                size = size + _M.Issue.Comment.calc_size_struct(data["comments"][i2])
            end
        end
        -- list
        if data["labels"] and type(data["labels"]) == "table" then
            local num2 = #data["labels"]
            for i2=1, num2 do
                size = size + 8
                 -- num * acutal size
                size = size + round8(#data["labels"][i2] * 1 + 1)
            end
        end
        -- text
        value = data["content"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["organization"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- list
        if data["git_host_refs"] and type(data["git_host_refs"]) == "table" then
            size = size + 8
            local num2 = #data["git_host_refs"]
            for i2=1, num2 do
                size = size + _M.Issue.GitHostRef.calc_size_struct(data["git_host_refs"][i2])
            end
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Issue.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 88 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["title"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Issue, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Issue, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["repo"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Issue, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Issue, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["milestone"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Issue, 2, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Issue, 2, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["assignees"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Issue, 3, pos)
            pos = pos + write_list(p32 + _M.Issue.dataWordCount * 2 + 3 * 2,
                    value, (data_off + 1) * 8, "list", "text")
        end

        value = data["is_closed"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 0, 0)
        end

        value = data["comments"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Issue, 4, pos)
            pos = pos + write_list(p32 + _M.Issue.dataWordCount * 2 + 4 * 2,
                    value, (data_off + 1) * 8, "list", "struct", _M.Issue.Comment)
        end

        value = data["labels"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Issue, 5, pos)
            pos = pos + write_list(p32 + _M.Issue.dataWordCount * 2 + 5 * 2,
                    value, (data_off + 1) * 8, "list", "text")
        end

        value = data["content"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Issue, 6, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Issue, 6, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["organization"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Issue, 7, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Issue, 7, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["mod_time"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint32", 32, 1, 0)
        end

        value = data["creation_time"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint32", 32, 2, 0)
        end

        value = data["git_host_refs"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Issue, 8, pos)
            pos = pos + write_list(p32 + _M.Issue.dataWordCount * 2 + 8 * 2,
                    value, (data_off + 1) * 8, "list", "struct", _M.Issue.GitHostRef)
        end

        value = data["state"]
        if type(value) == "string" or type(value) == "number" then
            local val = get_enum_val(value, 0, _M.Issue.State, "Issue.state")
            write_struct_field(p32, val, "uint16", 16, 1)
        end

        value = data["priority"]
        if type(value) == "string" or type(value) == "number" then
            local val = get_enum_val(value, 0, _M.Issue.Priority, "Issue.priority")
            write_struct_field(p32, val, "uint16", 16, 6)
        end

        value = data["type"]
        if type(value) == "string" or type(value) == "number" then
            local val = get_enum_val(value, 0, _M.Issue.Type, "Issue.type")
            write_struct_field(p32, val, "uint16", 16, 7)
        end

        value = data["in_github"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 1, 0)
        end
        return pos - start + 88
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Issue.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Issue, 0)

        -- skip header & struct pointer
        _M.Issue.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Issue, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (2 + 0 + 1 + off) * 2)
            s["title"] = ffi_string(p8, num - 1)
        else
            s["title"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Issue, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (2 + 1 + 1 + off) * 2)
            s["repo"] = ffi_string(p8, num - 1)
        else
            s["repo"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Issue, 2)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (2 + 2 + 1 + off) * 2)
            s["milestone"] = ffi_string(p8, num - 1)
        else
            s["milestone"] = nil
        end

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.Issue, 3)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["assignees"] = read_list_data(p32 + (2 + 3 + 1 + off) * 2, header,
                    num, "text")
        else
            s["assignees"] = nil
        end

        s["is_closed"] = read_struct_field(p32, "bool", 1, 0, 0)

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.Issue, 4)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["comments"] = read_list_data(p32 + (2 + 4 + 1 + off) * 2, header,
                    num, "struct", _M.Issue.Comment)
        else
            s["comments"] = nil
        end

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.Issue, 5)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["labels"] = read_list_data(p32 + (2 + 5 + 1 + off) * 2, header,
                    num, "text")
        else
            s["labels"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Issue, 6)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (2 + 6 + 1 + off) * 2)
            s["content"] = ffi_string(p8, num - 1)
        else
            s["content"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Issue, 7)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (2 + 7 + 1 + off) * 2)
            s["organization"] = ffi_string(p8, num - 1)
        else
            s["organization"] = nil
        end

        s["mod_time"] = read_struct_field(p32, "uint32", 32, 1, 0)

        s["creation_time"] = read_struct_field(p32, "uint32", 32, 2, 0)

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.Issue, 8)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["git_host_refs"] = read_list_data(p32 + (2 + 8 + 1 + off) * 2, header,
                    num, "struct", _M.Issue.GitHostRef)
        else
            s["git_host_refs"] = nil
        end

        -- enum
        local val = read_struct_field(p32, "uint16", 16, 1)
        s["state"] = get_enum_name(val, 0, _M.Issue.StateStr)

        -- enum
        local val = read_struct_field(p32, "uint16", 16, 6)
        s["priority"] = get_enum_name(val, 0, _M.Issue.PriorityStr)

        -- enum
        local val = read_struct_field(p32, "uint16", 16, 7)
        s["type"] = get_enum_name(val, 0, _M.Issue.TypeStr)

        s["in_github"] = read_struct_field(p32, "bool", 1, 1, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Issue.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Issue.Comment = {
    id = "17479926972322411658",
    displayName = "Big.capnp:Issue.Comment",
    dataWordCount = 1,
    pointerCount = 2,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "owner", default = "", ["type"] = "text" },
        { name = "comment", default = "", ["type"] = "text" },
        { name = "mod_time", default = 0, ["type"] = "uint32" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        -- text
        value = data["owner"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["comment"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Issue.Comment.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["owner"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Issue.Comment, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Issue.Comment, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["comment"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Issue.Comment, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Issue.Comment, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["mod_time"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint32", 32, 0, 0)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Issue.Comment.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Issue.Comment, 0)

        -- skip header & struct pointer
        _M.Issue.Comment.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Issue.Comment, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["owner"] = ffi_string(p8, num - 1)
        else
            s["owner"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Issue.Comment, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 1 + 1 + off) * 2)
            s["comment"] = ffi_string(p8, num - 1)
        else
            s["comment"] = nil
        end

        s["mod_time"] = read_struct_field(p32, "uint32", 32, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Issue.Comment.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Issue.GitHostRef = {
    id = "13392536535508071658",
    displayName = "Big.capnp:Issue.GitHostRef",
    dataWordCount = 1,
    pointerCount = 2,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "name", default = "", ["type"] = "text" },
        { name = "id", default = 0, ["type"] = "uint32" },
        { name = "url", default = "", ["type"] = "text" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        -- text
        value = data["name"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["url"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Issue.GitHostRef.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["name"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Issue.GitHostRef, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Issue.GitHostRef, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["id"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint32", 32, 0, 0)
        end

        value = data["url"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Issue.GitHostRef, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Issue.GitHostRef, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Issue.GitHostRef.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Issue.GitHostRef, 0)

        -- skip header & struct pointer
        _M.Issue.GitHostRef.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Issue.GitHostRef, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["name"] = ffi_string(p8, num - 1)
        else
            s["name"] = nil
        end

        s["id"] = read_struct_field(p32, "uint32", 32, 0, 0)

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Issue.GitHostRef, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 1 + 1 + off) * 2)
            s["url"] = ffi_string(p8, num - 1)
        else
            s["url"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Issue.GitHostRef.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Issue.State = {
    ["NEW"] = 0,
    ["INPROGRESS"] = 1,
    ["RESOLVED"] = 2,
    ["WONTFIX"] = 3,
    ["QUESTION"] = 4,
    ["CLOSED"] = 5,

}

_M.Issue.StateStr = {
    [0] = "NEW",
    [1] = "INPROGRESS",
    [2] = "RESOLVED",
    [3] = "WONTFIX",
    [4] = "QUESTION",
    [5] = "CLOSED",

}

_M.Issue.Priority = {
    ["MINOR"] = 0,
    ["NORMAL"] = 1,
    ["MAJOR"] = 2,
    ["CRITICAL"] = 3,

}

_M.Issue.PriorityStr = {
    [0] = "MINOR",
    [1] = "NORMAL",
    [2] = "MAJOR",
    [3] = "CRITICAL",

}

_M.Issue.Type = {
    ["UNKNOWN"] = 0,
    ["ALERT"] = 1,
    ["BUG"] = 2,
    ["DOC"] = 3,
    ["FEATURE"] = 4,
    ["INCIDENT"] = 5,
    ["QUESTION"] = 6,
    ["REQUEST"] = 7,
    ["STORY"] = 8,
    ["TASK"] = 9,

}

_M.Issue.TypeStr = {
    [0] = "UNKNOWN",
    [1] = "ALERT",
    [2] = "BUG",
    [3] = "DOC",
    [4] = "FEATURE",
    [5] = "INCIDENT",
    [6] = "QUESTION",
    [7] = "REQUEST",
    [8] = "STORY",
    [9] = "TASK",

}

_M.Organization = {
    id = "9834590311788152708",
    displayName = "Big.capnp:Organization",
    dataWordCount = 1,
    pointerCount = 6,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 9,

    fields = {
        { name = "owners", default = "opaque pointer", ["type"] = "list" },
        { name = "name", default = "", ["type"] = "text" },
        { name = "description", default = "", ["type"] = "text" },
        { name = "nr_issues", default = 0, ["type"] = "uint16" },
        { name = "nr_repos", default = 0, ["type"] = "uint16" },
        { name = "git_host_refs", default = "opaque pointer", ["type"] = "list" },
        { name = "members", default = "opaque pointer", ["type"] = "list" },
        { name = "repos", default = "opaque pointer", ["type"] = "list" },
        { name = "in_github", default = 0, ["type"] = "bool" },
    },

    calc_size_struct = function(data)
        local size = 56
        local value
        -- list
        if data["owners"] and type(data["owners"]) == "table" then
            local num2 = #data["owners"]
            for i2=1, num2 do
                size = size + 8
                 -- num * acutal size
                size = size + round8(#data["owners"][i2] * 1 + 1)
            end
        end
        -- text
        value = data["name"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["description"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- list
        if data["git_host_refs"] and type(data["git_host_refs"]) == "table" then
            size = size + 8
            local num2 = #data["git_host_refs"]
            for i2=1, num2 do
                size = size + _M.Organization.GitHostRef.calc_size_struct(data["git_host_refs"][i2])
            end
        end
        -- list
        if data["members"] and type(data["members"]) == "table" then
            size = size + 8
            local num2 = #data["members"]
            for i2=1, num2 do
                size = size + _M.Organization.Member.calc_size_struct(data["members"][i2])
            end
        end
        -- list
        if data["repos"] and type(data["repos"]) == "table" then
            size = size + 8
            local num2 = #data["repos"]
            for i2=1, num2 do
                size = size + _M.Organization.Repo.calc_size_struct(data["repos"][i2])
            end
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Organization.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 56 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["owners"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Organization, 0, pos)
            pos = pos + write_list(p32 + _M.Organization.dataWordCount * 2 + 0 * 2,
                    value, (data_off + 1) * 8, "list", "text")
        end

        value = data["name"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Organization, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Organization, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["description"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Organization, 2, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Organization, 2, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["nr_issues"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end

        value = data["nr_repos"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 1, 0)
        end

        value = data["git_host_refs"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Organization, 3, pos)
            pos = pos + write_list(p32 + _M.Organization.dataWordCount * 2 + 3 * 2,
                    value, (data_off + 1) * 8, "list", "struct", _M.Organization.GitHostRef)
        end

        value = data["members"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Organization, 4, pos)
            pos = pos + write_list(p32 + _M.Organization.dataWordCount * 2 + 4 * 2,
                    value, (data_off + 1) * 8, "list", "struct", _M.Organization.Member)
        end

        value = data["repos"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Organization, 5, pos)
            pos = pos + write_list(p32 + _M.Organization.dataWordCount * 2 + 5 * 2,
                    value, (data_off + 1) * 8, "list", "struct", _M.Organization.Repo)
        end

        value = data["in_github"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 32, 0)
        end
        return pos - start + 56
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Organization.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Organization, 0)

        -- skip header & struct pointer
        _M.Organization.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.Organization, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["owners"] = read_list_data(p32 + (1 + 0 + 1 + off) * 2, header,
                    num, "text")
        else
            s["owners"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Organization, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 1 + 1 + off) * 2)
            s["name"] = ffi_string(p8, num - 1)
        else
            s["name"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Organization, 2)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 2 + 1 + off) * 2)
            s["description"] = ffi_string(p8, num - 1)
        else
            s["description"] = nil
        end

        s["nr_issues"] = read_struct_field(p32, "uint16", 16, 0, 0)

        s["nr_repos"] = read_struct_field(p32, "uint16", 16, 1, 0)

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.Organization, 3)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["git_host_refs"] = read_list_data(p32 + (1 + 3 + 1 + off) * 2, header,
                    num, "struct", _M.Organization.GitHostRef)
        else
            s["git_host_refs"] = nil
        end

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.Organization, 4)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["members"] = read_list_data(p32 + (1 + 4 + 1 + off) * 2, header,
                    num, "struct", _M.Organization.Member)
        else
            s["members"] = nil
        end

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.Organization, 5)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["repos"] = read_list_data(p32 + (1 + 5 + 1 + off) * 2, header,
                    num, "struct", _M.Organization.Repo)
        else
            s["repos"] = nil
        end

        s["in_github"] = read_struct_field(p32, "bool", 1, 32, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Organization.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Organization.GitHostRef = {
    id = "13803331355186282940",
    displayName = "Big.capnp:Organization.GitHostRef",
    dataWordCount = 1,
    pointerCount = 2,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "name", default = "", ["type"] = "text" },
        { name = "id", default = 0, ["type"] = "uint32" },
        { name = "url", default = "", ["type"] = "text" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        -- text
        value = data["name"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["url"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Organization.GitHostRef.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["name"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Organization.GitHostRef, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Organization.GitHostRef, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["id"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint32", 32, 0, 0)
        end

        value = data["url"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Organization.GitHostRef, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Organization.GitHostRef, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Organization.GitHostRef.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Organization.GitHostRef, 0)

        -- skip header & struct pointer
        _M.Organization.GitHostRef.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Organization.GitHostRef, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["name"] = ffi_string(p8, num - 1)
        else
            s["name"] = nil
        end

        s["id"] = read_struct_field(p32, "uint32", 32, 0, 0)

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Organization.GitHostRef, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 1 + 1 + off) * 2)
            s["url"] = ffi_string(p8, num - 1)
        else
            s["url"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Organization.GitHostRef.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Organization.Member = {
    id = "9607610521605912755",
    displayName = "Big.capnp:Organization.Member",
    dataWordCount = 1,
    pointerCount = 2,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "key", default = "", ["type"] = "text" },
        { name = "access", default = 0, ["type"] = "uint16" },
        { name = "name", default = "", ["type"] = "text" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        -- text
        value = data["key"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["name"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Organization.Member.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["key"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Organization.Member, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Organization.Member, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["access"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end

        value = data["name"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Organization.Member, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Organization.Member, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Organization.Member.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Organization.Member, 0)

        -- skip header & struct pointer
        _M.Organization.Member.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Organization.Member, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["key"] = ffi_string(p8, num - 1)
        else
            s["key"] = nil
        end

        s["access"] = read_struct_field(p32, "uint16", 16, 0, 0)

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Organization.Member, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 1 + 1 + off) * 2)
            s["name"] = ffi_string(p8, num - 1)
        else
            s["name"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Organization.Member.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Organization.Repo = {
    id = "10309877176033115166",
    displayName = "Big.capnp:Organization.Repo",
    dataWordCount = 1,
    pointerCount = 2,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "key", default = "", ["type"] = "text" },
        { name = "name", default = "", ["type"] = "text" },
        { name = "access", default = 0, ["type"] = "uint16" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        -- text
        value = data["key"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["name"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Organization.Repo.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["key"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Organization.Repo, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Organization.Repo, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["name"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Organization.Repo, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Organization.Repo, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["access"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Organization.Repo.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Organization.Repo, 0)

        -- skip header & struct pointer
        _M.Organization.Repo.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Organization.Repo, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["key"] = ffi_string(p8, num - 1)
        else
            s["key"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Organization.Repo, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 1 + 1 + off) * 2)
            s["name"] = ffi_string(p8, num - 1)
        else
            s["name"] = nil
        end

        s["access"] = read_struct_field(p32, "uint16", 16, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Organization.Repo.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Repo = {
    id = "15067601828764847617",
    displayName = "Big.capnp:Repo",
    dataWordCount = 1,
    pointerCount = 5,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 8,

    fields = {
        { name = "owner", default = "", ["type"] = "text" },
        { name = "name", default = "", ["type"] = "text" },
        { name = "description", default = "", ["type"] = "text" },
        { name = "nr_issues", default = 0, ["type"] = "uint16" },
        { name = "nr_milestones", default = 0, ["type"] = "uint16" },
        { name = "members", default = "opaque pointer", ["type"] = "list" },
        { name = "git_host_refs", default = "opaque pointer", ["type"] = "list" },
        { name = "in_github", default = 0, ["type"] = "bool" },
    },

    calc_size_struct = function(data)
        local size = 48
        local value
        -- text
        value = data["owner"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["name"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["description"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- list
        if data["members"] and type(data["members"]) == "table" then
            size = size + 8
            local num2 = #data["members"]
            for i2=1, num2 do
                size = size + _M.Repo.Member.calc_size_struct(data["members"][i2])
            end
        end
        -- list
        if data["git_host_refs"] and type(data["git_host_refs"]) == "table" then
            size = size + 8
            local num2 = #data["git_host_refs"]
            for i2=1, num2 do
                size = size + _M.Repo.GitHostRef.calc_size_struct(data["git_host_refs"][i2])
            end
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Repo.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 48 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["owner"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Repo, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Repo, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["name"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Repo, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Repo, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["description"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Repo, 2, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Repo, 2, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["nr_issues"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end

        value = data["nr_milestones"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 1, 0)
        end

        value = data["members"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Repo, 3, pos)
            pos = pos + write_list(p32 + _M.Repo.dataWordCount * 2 + 3 * 2,
                    value, (data_off + 1) * 8, "list", "struct", _M.Repo.Member)
        end

        value = data["git_host_refs"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Repo, 4, pos)
            pos = pos + write_list(p32 + _M.Repo.dataWordCount * 2 + 4 * 2,
                    value, (data_off + 1) * 8, "list", "struct", _M.Repo.GitHostRef)
        end

        value = data["in_github"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 32, 0)
        end
        return pos - start + 48
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Repo.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Repo, 0)

        -- skip header & struct pointer
        _M.Repo.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Repo, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["owner"] = ffi_string(p8, num - 1)
        else
            s["owner"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Repo, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 1 + 1 + off) * 2)
            s["name"] = ffi_string(p8, num - 1)
        else
            s["name"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Repo, 2)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 2 + 1 + off) * 2)
            s["description"] = ffi_string(p8, num - 1)
        else
            s["description"] = nil
        end

        s["nr_issues"] = read_struct_field(p32, "uint16", 16, 0, 0)

        s["nr_milestones"] = read_struct_field(p32, "uint16", 16, 1, 0)

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.Repo, 3)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["members"] = read_list_data(p32 + (1 + 3 + 1 + off) * 2, header,
                    num, "struct", _M.Repo.Member)
        else
            s["members"] = nil
        end

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.Repo, 4)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["git_host_refs"] = read_list_data(p32 + (1 + 4 + 1 + off) * 2, header,
                    num, "struct", _M.Repo.GitHostRef)
        else
            s["git_host_refs"] = nil
        end

        s["in_github"] = read_struct_field(p32, "bool", 1, 32, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Repo.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Repo.Member = {
    id = "14899877748368591897",
    displayName = "Big.capnp:Repo.Member",
    dataWordCount = 1,
    pointerCount = 1,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "user_key", default = "", ["type"] = "text" },
        { name = "access", default = 0, ["type"] = "uint16" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        -- text
        value = data["user_key"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Repo.Member.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["user_key"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Repo.Member, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Repo.Member, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["access"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Repo.Member.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Repo.Member, 0)

        -- skip header & struct pointer
        _M.Repo.Member.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Repo.Member, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["user_key"] = ffi_string(p8, num - 1)
        else
            s["user_key"] = nil
        end

        s["access"] = read_struct_field(p32, "uint16", 16, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Repo.Member.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Repo.GitHostRef = {
    id = "15301511145421497055",
    displayName = "Big.capnp:Repo.GitHostRef",
    dataWordCount = 1,
    pointerCount = 2,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "name", default = "", ["type"] = "text" },
        { name = "id", default = 0, ["type"] = "uint32" },
        { name = "url", default = "", ["type"] = "text" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        -- text
        value = data["name"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["url"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Repo.GitHostRef.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["name"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Repo.GitHostRef, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Repo.GitHostRef, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["id"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint32", 32, 0, 0)
        end

        value = data["url"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Repo.GitHostRef, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Repo.GitHostRef, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Repo.GitHostRef.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Repo.GitHostRef, 0)

        -- skip header & struct pointer
        _M.Repo.GitHostRef.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Repo.GitHostRef, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["name"] = ffi_string(p8, num - 1)
        else
            s["name"] = nil
        end

        s["id"] = read_struct_field(p32, "uint32", 32, 0, 0)

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Repo.GitHostRef, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 1 + 1 + off) * 2)
            s["url"] = ffi_string(p8, num - 1)
        else
            s["url"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Repo.GitHostRef.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.User = {
    id = "18135016589371666633",
    displayName = "Big.capnp:User",
    dataWordCount = 1,
    pointerCount = 7,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 8,

    fields = {
        { name = "name", default = "", ["type"] = "text" },
        { name = "fullname", default = "", ["type"] = "text" },
        { name = "email", default = "", ["type"] = "text" },
        { name = "git_host_refs", default = "opaque pointer", ["type"] = "list" },
        { name = "github_id", default = "", ["type"] = "text" },
        { name = "telegram_id", default = "", ["type"] = "text" },
        { name = "iyo_id", default = "", ["type"] = "text" },
        { name = "in_github", default = 0, ["type"] = "bool" },
    },

    calc_size_struct = function(data)
        local size = 64
        local value
        -- text
        value = data["name"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["fullname"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["email"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- list
        if data["git_host_refs"] and type(data["git_host_refs"]) == "table" then
            size = size + 8
            local num2 = #data["git_host_refs"]
            for i2=1, num2 do
                size = size + _M.User.GitHostRef.calc_size_struct(data["git_host_refs"][i2])
            end
        end
        -- text
        value = data["github_id"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["telegram_id"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["iyo_id"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.User.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 64 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["name"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.User, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.User, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["fullname"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.User, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.User, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["email"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.User, 2, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.User, 2, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["git_host_refs"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.User, 3, pos)
            pos = pos + write_list(p32 + _M.User.dataWordCount * 2 + 3 * 2,
                    value, (data_off + 1) * 8, "list", "struct", _M.User.GitHostRef)
        end

        value = data["github_id"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.User, 4, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.User, 4, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["telegram_id"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.User, 5, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.User, 5, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["iyo_id"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.User, 6, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.User, 6, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["in_github"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 0, 0)
        end
        return pos - start + 64
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.User.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.User, 0)

        -- skip header & struct pointer
        _M.User.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.User, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["name"] = ffi_string(p8, num - 1)
        else
            s["name"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.User, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 1 + 1 + off) * 2)
            s["fullname"] = ffi_string(p8, num - 1)
        else
            s["fullname"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.User, 2)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 2 + 1 + off) * 2)
            s["email"] = ffi_string(p8, num - 1)
        else
            s["email"] = nil
        end

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.User, 3)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["git_host_refs"] = read_list_data(p32 + (1 + 3 + 1 + off) * 2, header,
                    num, "struct", _M.User.GitHostRef)
        else
            s["git_host_refs"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.User, 4)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 4 + 1 + off) * 2)
            s["github_id"] = ffi_string(p8, num - 1)
        else
            s["github_id"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.User, 5)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 5 + 1 + off) * 2)
            s["telegram_id"] = ffi_string(p8, num - 1)
        else
            s["telegram_id"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.User, 6)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 6 + 1 + off) * 2)
            s["iyo_id"] = ffi_string(p8, num - 1)
        else
            s["iyo_id"] = nil
        end

        s["in_github"] = read_struct_field(p32, "bool", 1, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.User.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.User.GitHostRef = {
    id = "14149814771852012356",
    displayName = "Big.capnp:User.GitHostRef",
    dataWordCount = 1,
    pointerCount = 2,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "name", default = "", ["type"] = "text" },
        { name = "id", default = 0, ["type"] = "uint32" },
        { name = "url", default = "", ["type"] = "text" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        -- text
        value = data["name"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["url"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.User.GitHostRef.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["name"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.User.GitHostRef, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.User.GitHostRef, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["id"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint32", 32, 0, 0)
        end

        value = data["url"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.User.GitHostRef, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.User.GitHostRef, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.User.GitHostRef.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.User.GitHostRef, 0)

        -- skip header & struct pointer
        _M.User.GitHostRef.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.User.GitHostRef, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["name"] = ffi_string(p8, num - 1)
        else
            s["name"] = nil
        end

        s["id"] = read_struct_field(p32, "uint32", 32, 0, 0)

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.User.GitHostRef, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 1 + 1 + off) * 2)
            s["url"] = ffi_string(p8, num - 1)
        else
            s["url"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.User.GitHostRef.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

return _M
